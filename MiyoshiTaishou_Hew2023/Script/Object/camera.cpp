#include "../Sysytem/main.h"
#include "../Sysytem/manager.h"

#include "../Render/renderer.h"

#include "camera.h"
#include"Player.h"
#include"field.h"

#include"../ImGui/ImGuiManager.h"

#include"../Scene/scene.h"

using namespace DirectX::SimpleMath;

void Camera::Init()
{
	m_Position = Vector3(0.0f, 10.0f, -50.0f);
	m_Target = Vector3(0.0f, 0.0f, 0.0f);

	Scene* nowscene = Manager::GetScene();
	Player* playerobj = nowscene->GetGameObject<Player>();

	m_Foward = playerobj->GetForward();
}

void Camera::Update()
{
	Scene* nowscene = Manager::GetScene();
	Player* playerobj = nowscene->GetGameObject<Player>();

	//カメラとプレイヤーを結ぶベクトル
	camForward = playerobj->GetPosition() - m_Position;
	camForward.Normalize();

	// ベクトルの横向き版を作成するために、Y軸とZ軸を入れ替えて符号を反転させることで90度回転させます
	camRight = Vector3(-camForward.z, 0.0f, camForward.x); // Y軸とZ軸を入れ替えてX軸を反転させる
	camRight.Normalize();

	// 球座標系でのカメラ位置を更新するためのパラメータ
	float radius = 50.0f; // カメラの距離


	// 球座標系からデカルト座標系へ変換してカメラ位置を計算
	Vector3 cameraPos;
	cameraPos.x = playerobj->GetPosition().x + radius * sin(phi) * cos(theta);
	cameraPos.y = playerobj->GetPosition().y + radius * cos(phi);
	cameraPos.z = playerobj->GetPosition().z + radius * sin(phi) * sin(theta);

	//m_Foward = this->GetForward();

	//m_Position = playerobj->GetPosition() - m_Foward * 50.0f;
	m_Position = cameraPos;
	this->m_Target = playerobj->GetPosition() /*+ m_Foward * 3.0f*/;

	// 緩やかカメラ処理
	// 1フレーム前のカメラ位置保存変数
	static Vector3 lastCamEye;
	float blendFactor = 0.5; // 平均化の重み
	m_Position.x = lastCamEye.x * blendFactor
		+ m_Position.x * (1.0f - blendFactor);
	m_Position.y = lastCamEye.y * blendFactor
		+ m_Position.y * (1.0f - blendFactor);
	m_Position.z = lastCamEye.z * blendFactor
		+ m_Position.z * (1.0f - blendFactor);

	lastCamEye = m_Position;

	this->m_Position.y += 30.0f;

	//this->m_Rotation.y = playerobj->GetRotation().y;	

	//高さを取得	
	Field* filed = nowscene->GetGameObject<Field>();
	if (!filed)
	{
		return;
	}

	//　範囲チェック 
	Vector3 max = filed->GetMax();
	Vector3 min = filed->GetMin();

	if (m_Position.x <= min.x) {
		m_Position.x = min.x;
	}
	if (m_Position.x >= max.x) {
		m_Position.x = max.x;
	}

	if (m_Position.z <= min.z) {
		m_Position.z = min.z;
	}
	if (m_Position.z >= max.z) {
		m_Position.z = max.z;
	}

	float Height = filed->GetFieldHeightBySqno(m_Position,*this);
}

void Camera::Draw()
{	
	// ビュー変換後列作成
	Vector3 up = Vector3(0.0f, 1.0f, 0.0f);
	m_ViewMatrix = DirectX::XMMatrixLookAtLH(m_Position, m_Target, up);										// 左手系にした　20230511 by suzuki.tomoki

	// DIRECTXTKのメソッドは右手系　20230511 by suzuki.tomoki
	// 右手系にすると３角形頂点が反時計回りになるので描画されなくなるので注意
	// このコードは確認テストのために残す
	//	m_ViewMatrix = m_ViewMatrix.CreateLookAt(m_Position, m_Target, up);					

	Renderer::SetViewMatrix(&m_ViewMatrix);

	//プロジェクション行列の生成
	constexpr float fieldOfView = DirectX::XMConvertToRadians(45.0f);    // 視野角

	float aspectRatio = static_cast<float>(SCREEN_WIDTH) / static_cast<float>(SCREEN_HEIGHT);	// アスペクト比	
	float nearPlane = 1.0f;       // ニアクリップ
	float farPlane = 1000.0f;      // ファークリップ

	//プロジェクション行列の生成
	Matrix projectionMatrix;
	projectionMatrix = DirectX::XMMatrixPerspectiveFovLH(fieldOfView, aspectRatio, nearPlane, farPlane);	// 左手系にした　20230511 by suzuki.tomoki

	// DIRECTXTKのメソッドは右手系　20230511 by suzuki.tomoki
	// 右手系にすると３角形頂点が反時計回りになるので描画されなくなるので注意
	// このコードは確認テストのために残す
//	projectionMatrix = DirectX::SimpleMath::Matrix::CreatePerspectiveFieldOfView(fieldOfView, aspectRatio, nearPlane, farPlane);

	Renderer::SetProjectionMatrix(&projectionMatrix);

	ImGui::Begin("Camera");
	ImGui::Text("%f,%f,%f", camForward.x, camForward.y, camForward.z);
	ImGui::Text("%f,%f,%f", camRight.x, camRight.y, camRight.z);
	ImGui::End();
}

void Camera::SetTarget(DirectX::SimpleMath::Vector3 target)
{
	m_Position = target;
}